module myapp

go 1.23

require (
	github.com/dgrijalva/jwt-go v3.2.0+incompatible // indirect
	github.com/lib/pq v1.10.9 // indirect
	github.com/rs/cors v1.10.1 // indirect
	golang.org/x/crypto v0.18.0 // indirect
)
github.com/dgrijalva/jwt-go v3.2.0+incompatible h1:7qlOGliEKZXTDg6OTjfoBKDXWrumCAMpl/TFQ4/5kLM=
github.com/dgrijalva/jwt-go v3.2.0+incompatible/go.mod h1:E3ru+11k8xSBh+hMPgOLZmtrrCbhqsmaPHjLKYnJCaQ=
github.com/lib/pq v1.10.9 h1:YXG7RB+JIjhP29X+OtkiDnYaXQwpS4JEWq7dtCCRUEw=
github.com/lib/pq v1.10.9/go.mod h1:AlVN5x4E4T544tWzH6hKfbfQvm3HdbOxrmggDNAPY9o=
github.com/rs/cors v1.10.1 h1:L0uuZVXIKlI1SShY2nhFfo44TYvDPQ1w4oFkUJNfhyo=
github.com/rs/cors v1.10.1/go.mod h1:XyqrcTp5zjWr1wsJ8PIRZssZ8b/WMcMf71DJnit4EMU=
golang.org/x/crypto v0.18.0 h1:PGVlW0xEltQnzFZ55hkuX5+KLyrMYhHld1YHO4AKcdc=
golang.org/x/crypto v0.18.0/go.mod h1:R0j02AL6hcrfOiy9T4ZYp/rcWeMxM3L6QYxlOuEG1mg=
package main

import (
    "log"
    "net/http"
    "os"
    "github.com/rs/cors" // ここは使用しているCORSライブラリに応じて変更してください
    "myapp/handlers"
    "myapp/db"   
)

func main() {
    log.SetOutput(os.Stdout)
    db.Init()

    // CORSミドルウェアの設定
    corsHandler := cors.New(cors.Options{
        AllowedOrigins: []string{"http://localhost:3000"},
        AllowedMethods: []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
        AllowCredentials: true,
    })

    http.Handle("/api/signup", corsHandler.Handler(http.HandlerFunc(handlers.SignUpHandler)))
    http.Handle("/api/personal-info", corsHandler.Handler(http.HandlerFunc(handlers.PersonalInfoHandler)))
    http.Handle("/api/login", corsHandler.Handler(http.HandlerFunc(handlers.LoginHandler)))
    http.Handle("/api/letter", corsHandler.Handler(http.HandlerFunc(handlers.LetterHandler)))
    http.Handle("/api/user/name", corsHandler.Handler(http.HandlerFunc(handlers.UserNameHandler)))
    http.Handle("/api/confirmation", corsHandler.Handler(http.HandlerFunc(handlers.ConfirmationHandler)))
    http.Handle("/api/logout", corsHandler.Handler(http.HandlerFunc(handlers.LogoutHandler)))

    log.Println("Server starting on http://localhost:8080")
    if err := http.ListenAndServe(":8080", nil); err != nil {
        log.Fatal("ListenAndServe:", err)
    }
}package db

import (
    "database/sql"
    _ "github.com/lib/pq"
    "log"
)

var DB *sql.DB

func Init() {
    var err error
    DB, err = sql.Open("postgres", "postgres://postgres:chousingc@localhost:5433/db?sslmode=disable")
    if err != nil {
        log.Fatal(err)
    }
    if err = DB.Ping(); err != nil {
        log.Fatal(err)
    }
}package handlers

import (
    "encoding/json"
    "log"
    "net/http"
    "strconv"

    "github.com/dgrijalva/jwt-go"
    "myapp/db"
    "myapp/models"
)

// confirmationHandler - 確認ページ用のハンドラー
func ConfirmationHandler(w http.ResponseWriter, r *http.Request) {
    // JWTトークンからユーザーIDを取得
    cookie, err := r.Cookie("token")
    if err != nil {
        http.Error(w, "Unauthorized", http.StatusUnauthorized)
        return
    }

    tokenString := cookie.Value
    claims := &jwt.StandardClaims{}
    _, err = jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
        return []byte("your_secret_key"), nil
    })

    // トークンの有効性の確認
    if err != nil {
        // ここで期限切れをチェック
        if ve, ok := err.(*jwt.ValidationError); ok {
            if ve.Errors&jwt.ValidationErrorExpired != 0 {
                // トークンが期限切れであることを示すエラーレスポンス
                http.Error(w, "Token expired", http.StatusUnauthorized)
                return
            }
        }
        // その他のエラー
        http.Error(w, "Unauthorized", http.StatusUnauthorized)
        return
    }

    userID, err := strconv.ParseInt(claims.Subject, 10, 64)
    if err != nil {
        http.Error(w, "Invalid token", http.StatusUnauthorized)
        return
    }

    // ユーザー情報の取得
    var userInfo models.UserInfo
    err = db.DB.QueryRow("SELECT username, email FROM users WHERE id = $1", userID).Scan(&userInfo.Username, &userInfo.Email)
    if err != nil {
        log.Printf("Error retrieving user info: %s", err)
        http.Error(w, "Server error", http.StatusInternalServerError)
        return
    }

    // 手紙情報の取得
    var letterInfo models.LetterInfo
    err = db.DB.QueryRow("SELECT content FROM letter WHERE user_id = $1 ORDER BY id DESC LIMIT 1", userID).Scan(&letterInfo.Content)
    if err != nil {
        log.Printf("Error retrieving letter info: %s", err)
        http.Error(w, "Server error", http.StatusInternalServerError)
        return
    }

    // 受取人情報の取得
    var recipientInfo models.RecipientInfo
    err = db.DB.QueryRow("SELECT name, address, phone_number, email, postal_code, send_date FROM recipient WHERE user_id = $1 ORDER BY id DESC LIMIT 1", userID).Scan(
        &recipientInfo.Name,
        &recipientInfo.Address,
        &recipientInfo.PhoneNumber,
        &recipientInfo.Email,
        &recipientInfo.PostalCode,
        &recipientInfo.SendDate,
    )
    if err != nil {
        log.Printf("Error retrieving recipient info: %s", err)
        http.Error(w, "Server error", http.StatusInternalServerError)
        return
    }

    // レスポンスの作成
    response := models.ConfirmationResponse{
        UserInfo:      userInfo,
        LetterInfo:    letterInfo,
        RecipientInfo: recipientInfo,
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(response)
}package handlers

import (
    "encoding/json"
    "log"
    "net/http"
    "strconv"

    "github.com/dgrijalva/jwt-go"
    "myapp/db"
)

func LetterHandler(w http.ResponseWriter, r *http.Request) {
    log.Println("Received a letter creation request")

    if err := r.ParseMultipartForm(10 << 20); err != nil {
        log.Printf("Error parsing multipart form: %s", err)
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }

    content := r.FormValue("content")
    fontSize := r.FormValue("fontSize")

    file, header, err := r.FormFile("file")
    if err != nil && err != http.ErrMissingFile {
        log.Printf("Error processing file: %s", err)
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }

    var filename string
    if file != nil {
        defer file.Close()
        filename = header.Filename
        log.Printf("File uploaded: %s", filename)
        // ファイル保存処理はここに実装します
    }

    cookie, err := r.Cookie("token")
    if err != nil {
        log.Printf("Error retrieving token cookie: %s", err)
        http.Error(w, "Unauthorized", http.StatusUnauthorized)
        return
    }

    tokenString := cookie.Value
    claims := &jwt.StandardClaims{}
    _, err = jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
        return []byte("your_secret_key"), nil
    })
    // トークンの有効性の確認
    if err != nil {
        // ここで期限切れをチェック
        if ve, ok := err.(*jwt.ValidationError); ok {
            if ve.Errors&jwt.ValidationErrorExpired != 0 {
                // トークンが期限切れであることを示すエラーレスポンス
                http.Error(w, "Token expired", http.StatusUnauthorized)
                return
            }
        }
        // その他のエラー
        http.Error(w, "Unauthorized", http.StatusUnauthorized)
        return
    }

    userID, err := strconv.ParseInt(claims.Subject, 10, 64)
    if err != nil {
        log.Printf("Error converting userID from token: %s", err)
        http.Error(w, "Invalid token", http.StatusUnauthorized)
        return
    }

	_, err = db.DB.Exec("INSERT INTO letter (user_id, content, font_size, filename) VALUES ($1, $2, $3, $4)", userID, content, fontSize, filename)
    if err != nil {
        log.Printf("Error inserting letter into database: %s", err)
        http.Error(w, "Server error", http.StatusInternalServerError)
        return
    }

    log.Println("Letter saved successfully")
    w.WriteHeader(http.StatusOK)
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(map[string]string{"message": "Letter saved successfully"})
}package handlers

import (
	"database/sql"
    "encoding/json"
    "log"
	"strconv"
    "net/http"
    "time"

    "golang.org/x/crypto/bcrypt"
	"github.com/dgrijalva/jwt-go"
    "myapp/db"
    "myapp/models"
)

func generateToken(userID int64) (string, error) {
    // トークンの有効期限を設定
    expirationTime := time.Now().Add(1 * time.Minute)

    // JWTクレームを作成
    claims := &jwt.StandardClaims{
        ExpiresAt: expirationTime.Unix(),
        Issuer:    "your-app-name",
        Subject:   strconv.FormatInt(userID, 10), // userIDを文字列に変換
    }

    // 新しいトークンを作成
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

    // シークレットキーでトークンに署名
    tokenString, err := token.SignedString([]byte("your_secret_key"))
    if err != nil {
        return "", err
    }

    return tokenString, nil
}



func LoginHandler(w http.ResponseWriter, r *http.Request) {
    var req models.LoginRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }

    var hashedPassword string
    var userID int64
    err := db.DB.QueryRow("SELECT id, password FROM users WHERE email = $1", req.Email).Scan(&userID, &hashedPassword)
    if err != nil {
        if err == sql.ErrNoRows {
            http.Error(w, "User not found", http.StatusUnauthorized)
            return
        }
        log.Printf("Database error: %s", err)
        http.Error(w, "Server error", http.StatusInternalServerError)
        return
    }

    if err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(req.Password)); err != nil {
        http.Error(w, "Invalid password", http.StatusUnauthorized)
        return
    }

    tokenString, err := generateToken(userID)
    if err != nil {
        log.Printf("Token generation error: %s", err)
        http.Error(w, "Server error", http.StatusInternalServerError)
        return
    }

    http.SetCookie(w, &http.Cookie{
        Name:     "token",
        Value:    tokenString,
        Expires:  time.Now().Add(1 * time.Minute),
        HttpOnly: true,
        Path:     "/",
        Secure:   false,
        SameSite: http.SameSiteStrictMode,
    })

    w.WriteHeader(http.StatusOK)
    json.NewEncoder(w).Encode("Login successful")
}package handlers

import (
    "net/http"
	"time"
)

func LogoutHandler(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Access-Control-Allow-Origin", "http://localhost:3000")
    w.Header().Set("Access-Control-Allow-Credentials", "true")
    // クッキーに保存されているセッショントークンを削除する処理
    http.SetCookie(w, &http.Cookie{
        Name:     "token",
        Value:    "",
        Path:     "/",
        Expires:  time.Unix(0, 0),
        MaxAge:   -1,
        HttpOnly: true,
    })

    // 応答を送信
    w.WriteHeader(http.StatusOK)
    w.Write([]byte("Logged out successfully"))
}
package handlers

import (
    "encoding/json"
    "log"
    "net/http"
    "strconv"
    "time"

    "github.com/dgrijalva/jwt-go"
    "myapp/db"
    "myapp/models"
)

// personalInfoHandler - 個人情報と決済情報を処理するハンドラー
func PersonalInfoHandler(w http.ResponseWriter, r *http.Request) {
    var req models.PersonalInfoRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        log.Printf("Error decoding request: %s", err)
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }

    // JWTトークンからユーザーIDを取得
    cookie, err := r.Cookie("token")
    if err != nil {
        http.Error(w, "Unauthorized", http.StatusUnauthorized)
        return
    }

    tokenString := cookie.Value
    claims := &jwt.StandardClaims{}
    _, err = jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
        return []byte("your_secret_key"), nil
    })
    // トークンの有効性の確認
    if err != nil {
        // ここで期限切れをチェック
        if ve, ok := err.(*jwt.ValidationError); ok {
            if ve.Errors&jwt.ValidationErrorExpired != 0 {
                // トークンが期限切れであることを示すエラーレスポンス
                http.Error(w, "Token expired", http.StatusUnauthorized)
                return
            }
        }
        // その他のエラー
        http.Error(w, "Unauthorized", http.StatusUnauthorized)
        return
    }

    userID, err := strconv.ParseInt(claims.Subject, 10, 64)
    if err != nil {
        http.Error(w, "Invalid token", http.StatusUnauthorized)
        return
    }

    // send_date が空の場合、現在の日時を設定
    sendDate := req.SendDate
    if sendDate == "" {
        sendDate = time.Now().Format("2006-01-02 15:04:05")
    }

    // recipient テーブルにデータを挿入
    _, err = db.DB.Exec("INSERT INTO recipient (user_id, name, address, postal_code, email, phone_number, send_date) VALUES ($1, $2, $3, $4, $5, $6, $7)",
        userID, req.RecipientName, req.RecipientAddress, req.RecipientZip, req.RecipientEmail, req.PhoneNumber, sendDate)
    if err != nil {
        log.Printf("Error inserting into recipient table: %s", err)
        http.Error(w, "Server error", http.StatusInternalServerError)
        return
    }

    // paymentinfo テーブルにデータを挿入
    expiryDate := "2028-06-30" // テスト用の固定された日付
    _, err = db.DB.Exec("INSERT INTO paymentinfo (user_id, card_number, expiry_date, cvv, billing_address) VALUES ($1, $2, $3, $4, $5)",
        userID, req.CardNumber, expiryDate, req.CVC, req.RecipientAddress)
    if err != nil {
        log.Printf("Error inserting into paymentinfo table: %s", err)
        http.Error(w, "Server error", http.StatusInternalServerError)
        return
    }

    w.WriteHeader(http.StatusOK)
    json.NewEncoder(w).Encode("Personal and payment information saved successfully")
}


// package handlers

// import (
//     "encoding/json"
//     "log"
//     "net/http"
//     "strconv"
//     "time"

//     "github.com/dgrijalva/jwt-go"
//     "myapp/db"
//     "myapp/models"
// )

// // personalInfoHandler - 個人情報と決済情報を処理するハンドラー
// func PersonalInfoHandler(w http.ResponseWriter, r *http.Request) {
//     var req models.PersonalInfoRequest
//     if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
//         log.Printf("Error decoding request: %s", err)
//         http.Error(w, err.Error(), http.StatusBadRequest)
//         return
//     }

//     // JWTトークンからユーザーIDを取得
//     cookie, err := r.Cookie("token")
//     if err != nil {
//         http.Error(w, "Unauthorized", http.StatusUnauthorized)
//         return
//     }

//     tokenString := cookie.Value
//     claims := &jwt.StandardClaims{}
//     token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
//         return []byte("your_secret_key"), nil
//     })


//     // トークンの有効性の確認
//     if err != nil {
//         // 期限切れをチェック
//         if ve, ok := err.(*jwt.ValidationError); ok {
//             if ve.Errors&jwt.ValidationErrorExpired != 0 {
//                 http.Error(w, "Token expired", http.StatusUnauthorized)
//                 return
//             }
//         }
//         http.Error(w, "Unauthorized", http.StatusUnauthorized)
//         return
//     }

//     if token == nil || !token.Valid {
//         http.Error(w, "Unauthorized", http.StatusUnauthorized)
//         return
//     }

//     userID, err := strconv.ParseInt(claims.Subject, 10, 64)
//     if err != nil {
//         http.Error(w, "Invalid token", http.StatusUnauthorized)
//         return
//     }

//     // send_date が空の場合、現在の日時を設定
//     sendDate := req.SendDate
//     if sendDate == "" {
//         sendDate = time.Now().Format("2006-01-02 15:04:05")
//     }

//     // recipient テーブルにデータを挿入
//     _, err = db.DB.Exec("INSERT INTO recipient (user_id, name, address, postal_code, email, phone_number, send_date) VALUES ($1, $2, $3, $4, $5, $6, $7)",
//         userID, req.RecipientName, req.RecipientAddress, req.RecipientZip, req.RecipientEmail, req.PhoneNumber, sendDate)
//     if err != nil {
//         log.Printf("Error inserting into recipient table: %s", err)
//         http.Error(w, "Server error", http.StatusInternalServerError)
//         return
//     }

//     // paymentinfo テーブルにデータを挿入
//     expiryDate := "2028-06-30" // テスト用の固定された日付
//     _, err = db.DB.Exec("INSERT INTO paymentinfo (user_id, card_number, expiry_date, cvv, billing_address) VALUES ($1, $2, $3, $4, $5)",
//         userID, req.CardNumber, expiryDate, req.CVC, req.RecipientAddress)
//     if err != nil {
//         log.Printf("Error inserting into paymentinfo table: %s", err)
//         http.Error(w, "Server error", http.StatusInternalServerError)
//         return
//     }

//     w.WriteHeader(http.StatusOK)
//     json.NewEncoder(w).Encode("Personal and payment information saved successfully")
// }package handlers

// import (
//     "myapp/db"
//     "myapp/models"
//     "log"
//     "encoding/json"
//     "net/http"
//     "golang.org/x/crypto/bcrypt"
// )

// func SignUpHandler(w http.ResponseWriter, r *http.Request) {
//     log.Println("Received a sign up request")

//     var req models.SignUpRequest
//     if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
//         log.Printf("Error decoding request: %s", err)
//         http.Error(w, err.Error(), http.StatusBadRequest)
//         return
//     }
//     log.Printf("Request data: %+v", req)

//     hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
//     if err != nil {
//         log.Printf("Error hashing password: %s", err)
//         http.Error(w, "Server error", http.StatusInternalServerError)
//         return
//     }
    
//     _, err = db.DB.Exec("INSERT INTO users (username, email, password) VALUES ($1, $2, $3)", req.Name, req.Email, string(hashedPassword))
//     if err != nil {
//         log.Printf("Error inserting user into database: %s", err)
//         http.Error(w, "Server error", http.StatusInternalServerError)
//         return
//     }

//     log.Println("User created successfully")
//     w.WriteHeader(http.StatusOK)
//     json.NewEncoder(w).Encode("User created successfully")
// }package handlers

// import (
// 	"database/sql"
//     "encoding/json"
//     "log"
//     "net/http"
//     "strconv"

//     "github.com/dgrijalva/jwt-go"
//     "myapp/db"
// )

// // userNameHandler
// func UserNameHandler(w http.ResponseWriter, r *http.Request) {
//     cookie, err := r.Cookie("token")
//     if err != nil {
//         http.Error(w, "Unauthorized", http.StatusUnauthorized)
//         return
//     }

//     tokenString := cookie.Value
//     claims := &jwt.StandardClaims{}
//     token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
//         return []byte("your_secret_key"), nil
//     })

//     if err != nil || !token.Valid {
//         http.Error(w, "Unauthorized", http.StatusUnauthorized)
//         return
//     }

//     userID, err := strconv.ParseInt(claims.Subject, 10, 64)
//     if err != nil {
//         log.Printf("Invalid user ID in token: %v", err)
//         http.Error(w, "Invalid token", http.StatusUnauthorized)
//         return
//     }

//     var userName string
//     err = db.DB.QueryRow("SELECT username FROM users WHERE id = $1", userID).Scan(&userName)
//     if err != nil {
//         if err == sql.ErrNoRows {
//             http.Error(w, "User not found", http.StatusNotFound)
//             return
//         }
//         log.Printf("Database error: %s", err)
//         http.Error(w, "Server error", http.StatusInternalServerError)
//         return
//     }

//     json.NewEncoder(w).Encode(map[string]string{"name": userName})
// }package models

// type SignUpRequest struct {
//     Email    string `json:"email"`
//     Name     string `json:"name"`
//     Address  string `json:"address"`
//     Password string `json:"password"`
// }

// type LoginRequest struct {
//     Email    string `json:"email"`
//     Password string `json:"password"`
// }

// type PersonalInfoRequest struct {
//     RecipientName    string `json:"recipientName"`
//     RecipientZip     string `json:"recipientZip"`
//     RecipientAddress string `json:"recipientAddress"`
//     RecipientEmail   string `json:"recipientEmail"`
//     CardName         string `json:"cardName"`
//     CardNumber       string `json:"cardNumber"`
//     ExpiryMonth      string `json:"expiryMonth"`
//     ExpiryYear       string `json:"expiryYear"`
//     CVC              string `json:"cvc"`
//     PhoneNumber      string `json:"phoneNumber"`
//     SendDate         string `json:"sendDate"`
// }

// type Letter struct {
//     Content  string `json:"content"`
//     FontSize string `json:"fontSize"`
//     Filename string `json:"filename"`
// }package models

// type ConfirmationResponse struct {
//     UserInfo      UserInfo      `json:"userInfo"`
//     LetterInfo    LetterInfo    `json:"letterInfo"`
//     RecipientInfo RecipientInfo `json:"recipientInfo"`
// }

// type UserInfo struct {
//     Username string `json:"username"`
//     Email    string `json:"email"`
// }

// type LetterInfo struct {
//     Content string `json:"content"`
// }

// type RecipientInfo struct {
//     Name        string `json:"name"`
//     Address     string `json:"address"`
//     PhoneNumber string `json:"phoneNumber"`
//     Email       string `json:"email"`
//     PostalCode  string `json:"postalCode"`
//     SendDate    string `json:"sendDate"`
// }